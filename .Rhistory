)
endpoints <- c(endpoints, list(endpoint))
}
return(endpoints)
}
endpoints <- get_endpoints(level3)
print(endpoints)
# A function tha cleans
clean_endpoints <- function(endpoints){
for (i in 1:length(endpoints)){
endpoints[[i]]$parents <- endpoints[[i]]$parents[-1]
for (j in 1:length(endpoints[[i]]$parents)){
split_string <- strsplit(endpoints[[i]]$parents[j], "/")[[1]]
desired_item <- split_string[length(split_string)]
endpoints[[i]]$parents[j] <- desired_item
}
}
return(endpoints)
}
endpoints <- clean_endpoints(endpoints)
print(endpoints)
blacklist <- compute_bad_nodes(endpoints)
compute_bad_nodes <- function(endpoints){
blacklist <- list()
for (i in 1:length(endpoints)){
result = 0
for (j in 1:length(endpoints[[i]]$parents)){
result = result + (calculate_dimer(endpoints[[i]]$endpoint, endpoints[[i]]$parents[j])$temp > threshold)
}
blacklist <- c(blacklist, result)
}
return(blacklist)
}
blacklist <- compute_bad_nodes(endpoints)
blacklist
compute_bad_nodes <- function(endpoints){
blacklist <- list()
for (i in 1:length(endpoints)){
result = 0
for (j in 1:length(endpoints[[i]]$parents)){
result = result + (calculate_dimer(endpoints[[i]]$endpoint, endpoints[[i]]$parents[j])$temp > threshold)
}
blacklist <- c(blacklist, result)
}
bad_nodes = endpoints[blacklist == 1]
return(bad_nodes)
}
bad_nodes <- compute_bad_nodes(endpoints)
print(bad_nodes)
# Print the filtered list
print(endpoints)
str(endpoints)
remove_list <- function(lst, path) {
if (length(path) == 1) {
if (is.list(lst) && path[[1]] %in% names(lst)) {
lst[[path[[1]]]] <- NULL
}
} else {
if (is.list(lst) && path[[1]] %in% names(lst)) {
lst[[path[[1]]]] <- remove_list(lst[[path[[1]]]], path[-1])
if (is.list(lst[[path[[1]]]]) && length(lst[[path[[1]]]]) == 0 && !any(names(lst[[path[[1]]]]))) {
lst[[path[[1]]]] <- NULL
}
}
}
lst
}
level3 <- Iterate_remove
Iterate_remove <- function(level3,bad_nodes){
for (i in 1:length(bad_nodes)){
level3 = remove_list(level3, c(bad_nodes[[i]]$parents, bad_nodes[[i]]$endpoint))
}
return(level3)
}
level3 <- Iterate_remove
str(level3)
get_endpoints <- function(lst, current_name = "", parent_names = character()) {
endpoints <- list()
if (is.list(lst)) {
if (length(lst) > 0) {
for (i in seq_along(lst)) {
nested_name <- names(lst)[i]
nested_value <- lst[[i]]
if (is.list(nested_value)) {
nested_endpoints <- get_endpoints(
nested_value,
paste(current_name, nested_name, sep = "/"),
c(parent_names, current_name)
)
endpoints <- c(endpoints, nested_endpoints)
} else {
endpoint <- list(
endpoint = nested_name,
parents = c(parent_names, current_name)
)
endpoints <- c(endpoints, list(endpoint))
}
}
} else {
endpoint <- list(
endpoint = current_name,
parents = parent_names
)
endpoints <- c(endpoints, list(endpoint))
}
} else {
endpoint <- list(
endpoint = current_name,
parents = parent_names
)
endpoints <- c(endpoints, list(endpoint))
}
return(endpoints)
}
endpoints <- get_endpoints(level3)
print(endpoints)
level3 <- temp
get_endpoints <- function(lst, current_name = "", parent_names = character()) {
endpoints <- list()
if (is.list(lst)) {
if (length(lst) > 0) {
for (i in seq_along(lst)) {
nested_name <- names(lst)[i]
nested_value <- lst[[i]]
if (is.list(nested_value)) {
nested_endpoints <- get_endpoints(
nested_value,
paste(current_name, nested_name, sep = "/"),
c(parent_names, current_name)
)
endpoints <- c(endpoints, nested_endpoints)
} else {
endpoint <- list(
endpoint = nested_name,
parents = c(parent_names, current_name)
)
endpoints <- c(endpoints, list(endpoint))
}
}
} else {
endpoint <- list(
endpoint = current_name,
parents = parent_names
)
endpoints <- c(endpoints, list(endpoint))
}
} else {
endpoint <- list(
endpoint = current_name,
parents = parent_names
)
endpoints <- c(endpoints, list(endpoint))
}
return(endpoints)
}
endpoints <- get_endpoints(level3)
print(endpoints)
endpoints <- clean_endpoints(endpoints)
print(endpoints)
print(endpoints)
compute_bad_nodes <- function(endpoints){
blacklist <- list()
for (i in 1:length(endpoints)){
result = 0
for (j in 1:length(endpoints[[i]]$parents)){
result = result + (calculate_dimer(endpoints[[i]]$endpoint, endpoints[[i]]$parents[j])$temp > threshold)
}
blacklist <- c(blacklist, result)
}
bad_nodes = endpoints[blacklist == 1]
return(bad_nodes)
}
bad_nodes <- compute_bad_nodes(endpoints)
for (i in 1:length(endpoints)){
result = 0
for (j in 1:length(endpoints[[i]]$parents)){
result = result + (calculate_dimer(endpoints[[i]]$endpoint, endpoints[[i]]$parents[j])$temp > threshold)
}
blacklist <- c(blacklist, result)
}
blacklist
Iterate_remove <- function(level3,bad_nodes){
for (i in 1:length(bad_nodes)){
level3 = remove_list(level3, c(bad_nodes[[i]]$parents, bad_nodes[[i]]$endpoint))
}
return(level3)
}
endpoints <- get_endpoints(level3)
print(endpoints)
endpoints <- clean_endpoints(endpoints)
print(endpoints)
bad_nodes <- compute_bad_nodes(endpoints)
#   result = 0
#   for (j in 1:length(endpoints[[i]]$parents)){
#    result = result + (calculate_dimer(endpoints[[i]]$endpoint, endpoints[[i]]$parents[j])$temp > threshold)
#   }
#   blacklist <- c(blacklist, result)
# }
#
# blacklist
#
# bad_nodes <- endpoints[blacklist == 1]
print(bad_nodes)
level3 <- Iterate_remove(level3,bad_nodes)
str(level3)
endpoints <- get_endpoints(level3)
print(endpoints)
level3 <- remove_empty_lists(level3)
str(level3)
level4 <- list()
for (item in get_list(2,3)[[1]]) {
# Create a sublist with the name as the item
sublist <- list(1)
names(sublist) <- item
level4[item] <- sublist
}
str(level3)
level4 <- list()
for (item in get_list(2,3)[[1]]) {
# Create a sublist with the name as the item
sublist <- list(1)
names(sublist) <- item
level4[item] <- sublist
}
list_3
top <- 25
level = 2
final = list()
df2$direction <- sapply(strsplit(as.character(df2$identity), " "), function(x) x[[2]])
df2$identity <- sapply(strsplit(as.character(df2$identity), " "), function(x) x[[1]])
df <- df2 %>%
group_by(identity) %>%
slice(1:top)%>%
ungroup()
nested_tables <- split(df, df$identity)
levels <- length(nested_tables) * 2
list_3 <- c()
## Clean out the nested table for the algorithum
get_list <- function(i, j){
k <- str_flatten(nested_tables[[i]][[j]], collapse = " ")
k <- as.list(strsplit(k, " "))
return(k)
}
# Remove duplciated primers under each SNP
for (i in 1:length(nested_tables)){
list_3 <- c(list_3,
list(unique(get_list(i,2)[[1]])),
list(unique(get_list(i,3)[[1]])))
}
list_3
# Arrange the list from small to big
arranged_list <- list_3[order(sapply(list_3, length),
decreasing = FALSE)]
arranged_list
arranged_list[1]
arranged_list[[1]]
arranged_list[[2]]
arranged_list[[3]]
arranged_list[[4]]
arranged_list[[4]][[1]]
# Gather incoming list
incoming_list <- function(level3, arranged_list){
level4 <- list()
for (item in arranged_list) {
# Create a sublist with the name as the item
sublist <- list(1)
names(sublist) <- item
level4[item] <- sublist
}
return(level4)
}
level3
str(level3)
arranged_list
arranged_list[[3]]
get_list(2,3)[[1]]
k <- incoming_list(level3, arranged_list[[3]])
str(k)
replace_end_nodes <- function(lst, replace_lst) {
if (is.list(lst)) {
if (length(lst) == 0) {
return(replace_lst)
} else {
return(lapply(lst, function(x) replace_end_nodes(x, replace_lst)))
}
} else {
return(replace_lst)
}
}
# replacing the end nodes so we have a new list at the end
replace_end_nodes <- function(lst, replace_lst) {
if (is.list(lst)) {
if (length(lst) == 0) {
return(replace_lst)
} else {
return(lapply(lst, function(x) replace_end_nodes(x, replace_lst)))
}
} else {
return(replace_lst)
}
}
# Apply the function to the nested list
level3 <- replace_end_nodes(level3, level4)
length(endpoints)
# Print the updated list
print(level3)
str(level3)
endpoints <- get_endpoints(level3)
length(endpoints)
source("recursive_tree_search.R")
source("Tree_function.R")
setwd("~/GitHub/Research-primer/Multiplexing App")
Data processing
library(DT)
library(dplyr)
library(tidyverse)
library(stringi)
library(stringr)
#graphing
library(ggplot2)
library(hexbin)
library(patchwork)
library(plotly)
# Bioinformatics
library(biomaRt)
library(spgs)
library(primer3)
# Deployment
library(shinydashboard)
library(shiny)
source("functions.R")
source("Tree_function.R")
options(repos = BiocManager::repositories())
source("Tree_function.R")
source("Tree_function.R")
## Clean out the nested table for the algorithum
get_list <- function(i, j){
k <- str_flatten(nested_tables[[i]][[j]], collapse = " ")
k <- as.list(strsplit(k, " "))
return(k)
}
# Get all endpoints and give parents and children
get_endpoints <- function(lst, current_name = "", parent_names = character()) {
endpoints <- list()
if (is.list(lst)) {
if (length(lst) > 0) {
for (i in seq_along(lst)) {
nested_name <- names(lst)[i]
nested_value <- lst[[i]]
if (is.list(nested_value)) {
nested_endpoints <- get_endpoints(
nested_value,
paste(current_name, nested_name, sep = "/"),
c(parent_names, current_name)
)
endpoints <- c(endpoints, nested_endpoints)
} else {
endpoint <- list(
endpoint = nested_name,
parents = c(parent_names, current_name)
)
endpoints <- c(endpoints, list(endpoint))
}
}
} else {
endpoint <- list(
endpoint = current_name,
parents = parent_names
)
endpoints <- c(endpoints, list(endpoint))
}
} else {
endpoint <- list(
endpoint = current_name,
parents = parent_names
)
endpoints <- c(endpoints, list(endpoint))
}
return(endpoints)
}
# A function tha cleans
clean_endpoints <- function(endpoints){
for (i in 1:length(endpoints)){
endpoints[[i]]$parents <- endpoints[[i]]$parents[-1]
for (j in 1:length(endpoints[[i]]$parents)){
split_string <- strsplit(endpoints[[i]]$parents[j], "/")[[1]]
desired_item <- split_string[length(split_string)]
endpoints[[i]]$parents[j] <- desired_item
}
}
return(endpoints)
}
# find the bad nodes
compute_bad_nodes <- function(endpoints){
blacklist <- list()
for (i in 1:length(endpoints)){
result = 0
for (j in 1:length(endpoints[[i]]$parents)){
result = result + (calculate_dimer(endpoints[[i]]$endpoint, endpoints[[i]]$parents[j])$temp > threshold)
}
blacklist <- c(blacklist, result)
}
bad_nodes = endpoints[blacklist == 1]
return(bad_nodes)
}
### Remove unqualafied nods from the OG df
remove_list <- function(lst, path) {
if (length(path) == 1) {
if (is.list(lst) && path[[1]] %in% names(lst)) {
lst[[path[[1]]]] <- NULL
}
} else {
if (is.list(lst) && path[[1]] %in% names(lst)) {
lst[[path[[1]]]] <- remove_list(lst[[path[[1]]]], path[-1])
if (is.list(lst[[path[[1]]]]) && length(lst[[path[[1]]]]) == 0 && !any(names(lst[[path[[1]]]]))) {
lst[[path[[1]]]] <- NULL
}
}
}
lst
}
## remove the trunk
remove_empty_lists <- function(lst) {
if (is.list(lst)) {
lst <- lapply(lst, remove_empty_lists)
lst <- lst[lengths(lst) > 0]
}
lst
}
### Remove based on index
Iterate_remove <- function(level3,bad_nodes){
for (i in 1:length(bad_nodes)){
level3 = remove_list(level3, c(bad_nodes[[i]]$parents, bad_nodes[[i]]$endpoint))
}
return(level3)
}
# Gather incoming list
incoming_list <- function(level3, arranged_list){
level4 <- list()
for (item in arranged_list) {
# Create a sublist with the name as the item
sublist <- list(1)
names(sublist) <- item
level4[item] <- sublist
}
return(level4)
}
# replacing the end nodes so we have a new list at the end
replace_end_nodes <- function(lst, replace_lst) {
if (is.list(lst)) {
if (length(lst) == 0) {
return(replace_lst)
} else {
return(lapply(lst, function(x) replace_end_nodes(x, replace_lst)))
}
} else {
return(replace_lst)
}
}
source("Tree_function.R")
source("Tree_function.R")
source("Tree_function.R")
source("functions.R")
# Data processing
library(DT)
library(dplyr)
library(tidyverse)
library(stringi)
library(stringr)
#graphing
library(ggplot2)
library(hexbin)
library(patchwork)
library(plotly)
# Bioinformatics
library(biomaRt)
library(spgs)
library(primer3)
# Deployment
library(shinydashboard)
library(shiny)
source("functions.R")
options(repos = BiocManager::repositories())
primer <- "rs1121980, rs9939609, rs7903146, rs4402960"
primer_away <- 250
primer_min <- 18
primer_max <- 25
primer_left_min <- 18
primer_left_max <- 25
left_TM <- 70
right_TM <- 70
left_hair_TM <- 35
right_hair_TM <- 35
diff <- 2
Homodimer_left_dg <- 30
Homodimer_right_dg <- 30
Heterodimer_dg <- 10
shift <- 400
left_TM_max = 66
left_TM_min = 60
threshold = 5
center = 800
center <- 800
## Not sure why, but it works
primer_away <- -primer_away
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
upStream <- center
downStream <- center
snpmart <- useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp")
snpmart <- useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp")
