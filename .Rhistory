}
# Stop the cluster
stopCluster(cl)
# Combine the results
combined_results <- unlist(results)
end_time <- Sys.time()
# Calculate the elapsed time
elapsed_time <- end_time - start_time
# Print the elapsed time
print(elapsed_time)
}
df2 <- read.csv("metadata.csv")[,-1]
df2$direction <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[2]])
df2$Identity <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[1]])
df <- df2 %>%
group_by(Identity) %>%
slice(1:top)%>%
ungroup()
nested_tables <- split(df, df$Identity)
le <- length(nested_tables)
top <- 5
threshold = 10
level = 2
final = matrix()
df2 <- read.csv("metadata.csv")[,-1]
df2$direction <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[2]])
df2$Identity <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[1]])
df <- df2 %>%
group_by(Identity) %>%
slice(1:top)%>%
ungroup()
nested_tables <- split(df, df$Identity)
le <- length(nested_tables)
get_list <- function(i, j){
k <- str_flatten(nested_tables[[i]][[j]], collapse = " ")
k <- as.list(strsplit(k, " "))
return(k)
}
list_1 = c(list(unique(get_list(1,2)[[1]])),
list(unique(get_list(1,3)[[1]])),
list(unique(get_list(2,2)[[1]])),
list(unique(get_list(2,3)[[1]])))
list_2 = c(list(unique(get_list(3,2)[[1]])),
list(unique(get_list(3,3)[[1]])),
list(unique(get_list(4,2)[[1]])),
list(unique(get_list(4,3)[[1]])))
combination <- expand.grid(append(list_1, list_2))
View(combination)
matrix_data <- combination
# Calculate the number of rows in each part
rows_per_part <- ceiling(nrow(matrix_data) / n)
n <- 10
# Calculate the number of rows in each part
rows_per_part <- ceiling(nrow(matrix_data) / n)
rows_per_part
# Divide the matrix into parts and store them in a list
divided_matrix <- split(matrix_data, rep(1:n, each = rows_per_part, length.out = nrow(matrix_data)))
# Iterate through the divided parts in the list
for (i in 1:n) {
current_part <- divided_matrix[[i]]
# Do something with the current_part
print(current_part)
}
current_part
divided_matrix
for (i in divided_matrix){}
for (i in divided_matrix){print(i)}
###################
evaluation <- function(combination){
num_rows <- nrow(combination)
num_cols <- ncol(combination)
permutation <- factorial(num_cols)/factorial(num_cols-2)/2
result_matrix <- matrix(0, nrow = num_rows, ncol = permutation)
# Iterate over each row of the matrix
for (i in 1:num_rows) {
row <- combination[i, ]
row <- lapply(row, as.character)
clock = 0
print(paste("i is", i))
for (j in 1:num_cols) {
#print(paste("j is", j))
if (1){
for (k in j:num_cols) {
if (k>j){
clock = clock + 1
result_matrix[i, clock] <- calculate_dimer(row[[j]], row[[k]])$temp
}
}
}
}
}
result_matrix <- as.data.frame(result_matrix)
row_indices <- which(apply(result_matrix, 1, function(row) all(row < 5)))
# indices_1 <- unique(ceiling(row_indices/len_1))
# indices_2 <- unique(sapply(row_indices,
#                            function(x) if(x%%len_2 == 0){return(len_2)}
#                            else
#                              {return(x%%len_2)} ))
# print(indices_1)
# print(indices_2)
return(result_matrix)
}
################################
{
# Apply the function in parallel
start_time <- Sys.time()
results <- foreach(i = divided_matrix) %dopar% {
evaluation(i)
}
stopCluster(cl)
#combined_results <- unlist(results)
end_time <- Sys.time()
elapsed_time <- end_time - start_time
print(elapsed_time)
}
numCores <- detectCores()
cl <- makeCluster(numCores)
registerDoParallel(cl)
clusterEvalQ(cl, {
library(primer3)
library(stringr)
})
################################
{
# Apply the function in parallel
start_time <- Sys.time()
results <- foreach(i = divided_matrix) %dopar% {
evaluation(i)
}
stopCluster(cl)
#combined_results <- unlist(results)
end_time <- Sys.time()
elapsed_time <- end_time - start_time
print(elapsed_time)
}
results
View(results)
results[1]
results[[1]]
k <- results[[1]]
View(k)
combined_matrix <- do.call(rbind, results)
View(combined_matrix)
num_rows <- nrow(combination)
num_cols <- ncol(combination)
permutation <- factorial(num_cols)/factorial(num_cols-2)/2
result_matrix <- matrix(0, nrow = num_rows, ncol = permutation)
# Iterate over each row of the matrix
for (i in 1:num_rows) {
row <- combination[i, ]
row <- lapply(row, as.character)
clock = 0
print(paste("i is", i))
for (j in 1:num_cols) {
#print(paste("j is", j))
if (1){
for (k in j:num_cols) {
if (k>j){
#print(paste("k is", k))
clock = clock + 1
#print(paste("Order ----------- ", clock))
#print(row[[j]])
#print(row[[k]])
result_matrix[i, clock] <- calculate_dimer(row[[j]], row[[k]])$temp
}
}
}
}
}
start_time <- Sys.time()
for (i in 1:num_rows) {
row <- combination[i, ]
row <- lapply(row, as.character)
clock = 0
print(paste("i is", i))
for (j in 1:num_cols) {
#print(paste("j is", j))
if (1){
for (k in j:num_cols) {
if (k>j){
#print(paste("k is", k))
clock = clock + 1
#print(paste("Order ----------- ", clock))
#print(row[[j]])
#print(row[[k]])
result_matrix[i, clock] <- calculate_dimer(row[[j]], row[[k]])$temp
}
}
}
}
}
end_time <- Sys.time()
print(elapsed_time <- end_time - start_time)
start_time <- Sys.time()
for (i in 1:num_rows) {
row <- combination[i, ]
row <- lapply(row, as.character)
clock = 0
#print(paste("i is", i))
for (j in 1:num_cols) {
#print(paste("j is", j))
if (1){
for (k in j:num_cols) {
if (k>j){
#print(paste("k is", k))
clock = clock + 1
#print(paste("Order ----------- ", clock))
#print(row[[j]])
#print(row[[k]])
result_matrix[i, clock] <- calculate_dimer(row[[j]], row[[k]])$temp
}
}
}
}
}
end_time <- Sys.time()
print(elapsed_time <- end_time - start_time)
top <- 20
threshold = 10
level = 2
final = matrix()
df2 <- read.csv("metadata.csv")[,-1]
df2$direction <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[2]])
df2$Identity <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[1]])
df <- df2 %>%
group_by(Identity) %>%
slice(1:top)%>%
ungroup()
nested_tables <- split(df, df$Identity)
le <- length(nested_tables)
get_list <- function(i, j){
k <- str_flatten(nested_tables[[i]][[j]], collapse = " ")
k <- as.list(strsplit(k, " "))
return(k)
}
list_1 = c(list(unique(get_list(1,2)[[1]])),
list(unique(get_list(1,3)[[1]])),
list(unique(get_list(2,2)[[1]])),
list(unique(get_list(2,3)[[1]])))
list_2 = c(list(unique(get_list(3,2)[[1]])),
list(unique(get_list(3,3)[[1]])),
list(unique(get_list(4,2)[[1]])),
list(unique(get_list(4,3)[[1]])))
level = level + 1
combination <- expand.grid(append(list_1, list_2))
num_rows <- nrow(combination)
num_cols <- ncol(combination)
permutation <- factorial(num_cols)/factorial(num_cols-2)/2
result_matrix <- matrix(0, nrow = num_rows, ncol = permutation)
start_time <- Sys.time()
for (i in 1:num_rows) {
row <- combination[i, ]
row <- lapply(row, as.character)
clock = 0
#print(paste("i is", i))
for (j in 1:num_cols) {
#print(paste("j is", j))
if (max(result_matrix[i, ]) <= threshold){
for (k in j:num_cols) {
if (k>j){
#print(paste("k is", k))
clock = clock + 1
#print(paste("Order ----------- ", clock))
#print(row[[j]])
#print(row[[k]])
result_matrix[i, clock] <- calculate_dimer(row[[j]], row[[k]])$temp
}
}
}
}
}
end_time <- Sys.time()
print(elapsed_time <- end_time - start_time)
top <- 10
threshold = 10
level = 2
final = matrix()
df2 <- read.csv("metadata.csv")[,-1]
df2$direction <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[2]])
df2$Identity <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[1]])
df <- df2 %>%
group_by(Identity) %>%
slice(1:top)%>%
ungroup()
nested_tables <- split(df, df$Identity)
le <- length(nested_tables)
get_list <- function(i, j){
k <- str_flatten(nested_tables[[i]][[j]], collapse = " ")
k <- as.list(strsplit(k, " "))
return(k)
}
list_1 = c(list(unique(get_list(1,2)[[1]])),
list(unique(get_list(1,3)[[1]])),
list(unique(get_list(2,2)[[1]])),
list(unique(get_list(2,3)[[1]])))
list_2 = c(list(unique(get_list(3,2)[[1]])),
list(unique(get_list(3,3)[[1]])),
list(unique(get_list(4,2)[[1]])),
list(unique(get_list(4,3)[[1]])))
combination <- expand.grid(append(list_1, list_2))
num_rows <- nrow(combination)
num_cols <- ncol(combination)
permutation <- factorial(num_cols)/factorial(num_cols-2)/2
result_matrix <- matrix(0, nrow = num_rows, ncol = permutation)
# Iterate over each row of the matrix
start_time <- Sys.time()
for (i in 1:num_rows) {
row <- combination[i, ]
row <- lapply(row, as.character)
clock = 0
#print(paste("i is", i))
for (j in 1:num_cols) {
#print(paste("j is", j))
if (max(result_matrix[i, ]) <= threshold){
for (k in j:num_cols) {
if (k>j){
#print(paste("k is", k))
clock = clock + 1
#print(paste("Order ----------- ", clock))
#print(row[[j]])
#print(row[[k]])
result_matrix[i, clock] <- calculate_dimer(row[[j]], row[[k]])$temp
}
}
}
}
}
end_time <- Sys.time()
print(elapsed_time <- end_time - start_time)
###################
evaluation <- function(combination){
num_rows <- nrow(combination)
num_cols <- ncol(combination)
permutation <- factorial(num_cols)/factorial(num_cols-2)/2
result_matrix <- matrix(0, nrow = num_rows, ncol = permutation)
# Iterate over each row of the matrix
for (i in 1:num_rows) {
row <- combination[i, ]
row <- lapply(row, as.character)
clock = 0
print(paste("i is", i))
for (j in 1:num_cols) {
#print(paste("j is", j))
if (max(result_matrix[i, ]) <= threshold){
for (k in j:num_cols) {
if (k>j){
clock = clock + 1
result_matrix[i, clock] <- calculate_dimer(row[[j]], row[[k]])$temp
}
}
}
}
}
result_matrix <- as.data.frame(result_matrix)
row_indices <- which(apply(result_matrix, 1, function(row) all(row < 5)))
# indices_1 <- unique(ceiling(row_indices/len_1))
# indices_2 <- unique(sapply(row_indices,
#                            function(x) if(x%%len_2 == 0){return(len_2)}
#                            else
#                              {return(x%%len_2)} ))
# print(indices_1)
# print(indices_2)
return(result_matrix)
}
matrix_data <- combination
n <- 10
# Calculate the number of rows in each part
rows_per_part <- ceiling(nrow(matrix_data) / n)
# Divide the matrix into parts and store them in a list
divided_matrix <- split(matrix_data, rep(1:n, each = rows_per_part, length.out = nrow(matrix_data)))
# Iterate through the divided parts in the list
for (i in 1:n) {
current_part <- divided_matrix[[i]]
# Do something with the current_part
print(current_part)
}
matrix_data <- combination
n <- 12
# Calculate the number of rows in each part
rows_per_part <- ceiling(nrow(matrix_data) / n)
# Divide the matrix into parts and store them in a list
divided_matrix <- split(matrix_data, rep(1:n, each = rows_per_part, length.out = nrow(matrix_data)))
################################
{
# Apply the function in parallel
start_time <- Sys.time()
results <- foreach(i = divided_matrix) %dopar% {
evaluation(i)
}
combined_matrix <- do.call(rbind, results)
stopCluster(cl)
#combined_results <- unlist(results)
end_time <- Sys.time()
print(elapsed_time <- end_time - start_time)
}
numCores <- detectCores()
cl <- makeCluster(numCores)
registerDoParallel(cl)
clusterEvalQ(cl, {
library(primer3)
library(stringr)
})
################################
{
# Apply the function in parallel
start_time <- Sys.time()
results <- foreach(i = divided_matrix) %dopar% {
evaluation(i)
}
combined_matrix <- do.call(rbind, results)
stopCluster(cl)
#combined_results <- unlist(results)
end_time <- Sys.time()
print(elapsed_time <- end_time - start_time)
}
View(combined_matrix)
threshold = 20
level = 2
final = matrix()
df2 <- read.csv("metadata.csv")[,-1]
df2$direction <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[2]])
df2$Identity <- sapply(strsplit(as.character(df2$Identity), " "), function(x) x[[1]])
df <- df2 %>%
group_by(Identity) %>%
slice(1:top)%>%
ungroup()
nested_tables <- split(df, df$Identity)
le <- length(nested_tables)
get_list <- function(i, j){
k <- str_flatten(nested_tables[[i]][[j]], collapse = " ")
k <- as.list(strsplit(k, " "))
return(k)
}
list_1 = c(list(unique(get_list(1,2)[[1]])),
list(unique(get_list(1,3)[[1]])),
list(unique(get_list(2,2)[[1]])),
list(unique(get_list(2,3)[[1]])))
list_2 = c(list(unique(get_list(3,2)[[1]])),
list(unique(get_list(3,3)[[1]])),
list(unique(get_list(4,2)[[1]])),
list(unique(get_list(4,3)[[1]])))
combination <- expand.grid(append(list_1, list_2))
numCores <- detectCores()
cl <- makeCluster(numCores)
registerDoParallel(cl)
clusterEvalQ(cl, {
library(primer3)
library(stringr)
})
###################
evaluation <- function(combination){
num_rows <- nrow(combination)
num_cols <- ncol(combination)
permutation <- factorial(num_cols)/factorial(num_cols-2)/2
result_matrix <- matrix(0, nrow = num_rows, ncol = permutation)
# Iterate over each row of the matrix
for (i in 1:num_rows) {
row <- combination[i, ]
row <- lapply(row, as.character)
clock = 0
print(paste("i is", i))
for (j in 1:num_cols) {
#print(paste("j is", j))
if (max(result_matrix[i, ]) <= threshold){
for (k in j:num_cols) {
if (k>j){
clock = clock + 1
result_matrix[i, clock] <- calculate_dimer(row[[j]], row[[k]])$temp
}
}
}
}
}
result_matrix <- as.data.frame(result_matrix)
row_indices <- which(apply(result_matrix, 1, function(row) all(row < 5)))
# indices_1 <- unique(ceiling(row_indices/len_1))
# indices_2 <- unique(sapply(row_indices,
#                            function(x) if(x%%len_2 == 0){return(len_2)}
#                            else
#                              {return(x%%len_2)} ))
# print(indices_1)
# print(indices_2)
return(result_matrix)
}
matrix_data <- combination
n <- 12
# Calculate the number of rows in each part
rows_per_part <- ceiling(nrow(matrix_data) / n)
# Divide the matrix into parts and store them in a list
divided_matrix <- split(matrix_data, rep(1:n, each = rows_per_part, length.out = nrow(matrix_data)))
################################
{
# Apply the function in parallel
start_time <- Sys.time()
results <- foreach(i = divided_matrix) %dopar% {
evaluation(i)
}
combined_matrix <- do.call(rbind, results)
stopCluster(cl)
#combined_results <- unlist(results)
end_time <- Sys.time()
print(elapsed_time <- end_time - start_time)
}
View(combined_matrix)
calculate_dimer("ACTTTCTCACACAAGCCTCTGAAACC
", "TGTGATGCACTTGGATAGTCTCTGT")
calculate_dimer("ACTTTCTCACACAAGCCTCTGAAACC
", "TGTGATGCACTTGGATAGTCTCTGT")$temp
calculate_dimer("TTAGGAACAACTGCCTGTGTGAG
", "ACTTTCTCACACAAGCCTCTGAAACC")$temp
calculate_dimer("TAGAGAGCTAAGCACTTTTTAGATAC
", "ACTTTTTTTAATAGGAAAGTCTGGTA")$temp
