print("R get filter activated")
# Applied filters before multiplexing
df <- stage1_filter(df, desired_tm, diff, Homodimer, hairpin)
print(df)
print("Filtered")
runApp()
source("functions.R")
primer = "rs53576, rs1815739, rs7412, rs429358, rs6152"
shift = 100
desired_tm = 60
diff = 4
Heterodimer_tm = 50
Homodimer <- 45
top <- 2
# We will start exploring options 800 bp away from the SNP location upstream and downstream
center <- 800
hairpin <- 45
# from that distance of 800, we will search the range from 600 to 1,000. (800+200 and 800-200)
far <- 200
start_distance <- 15
end_distance <- 30
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
upStream <- center
downStream <- center
snpmart <- useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp")
snp_sequence <- getBM(attributes = c('refsnp_id', 'snp'),
filters = c('snp_filter', 'upstream_flank', 'downstream_flank'),
checkFilters = FALSE,
values = list(snp_list, upStream, downStream),
mart = snpmart,
bmHeader = TRUE)
#Create a new data frame
snp_wrangled <- data.frame(matrix(ncol = 2, nrow = 0))
# Add each variation as a new string into each row
for (j in snp_sequence$`Variant name`){
for (i in list_seq(snp_sequence$`Variant sequences`[snp_sequence$`Variant name`==j])){
snp_wrangled[nrow(snp_wrangled) + 1,] <- c(j, i)
}
}
# Rename columns and data frame
colnames(snp_wrangled) = c("snpID", "sequence")
### I have a long long string. I want to get the left 18~25 charactors and
# between 300 ~ 800 units away, I want another 18 ~ 25
df <- all_text_warngling(snp_wrangled,
start_distance,
end_distance,
center,
far,
shift)
df
print("Primer generated")
print("R get filter activated")
# Applied filters before multiplexing
df <- stage1_filter(df, desired_tm, diff, Homodimer, hairpin)
print(df)
# Count how many candidates there are for each primer group
df <- df %>%
mutate(substrings_count = lengths(substrings),
faraway_count = lengths(faraway)) %>%
relocate(snpID, substrings_count, faraway_count, everything()) # Moves a block of columns
print("Tree search")
df
# Keep only certain amount of candidates
df[[4]] <- extract_top_n(df[[4]], top)
df[[5]] <- extract_top_n(df[[5]], top)
df <- df %>%
group_by(snpID) %>%
filter(substrings_count == max(substrings_count))
print(df)
level5 <- soulofmultiplex(df, Heterodimer_tm)
print(level5)
level5
rownames(level5)
level5_with_tm_result <- data.frame(matrix(NA, nrow = nrow(level5), ncol = 0))
# Apply the 'calculate_tm' function to each column of the dataframe
for (i in seq_along(level5)) {
# Calculate TM for the column and round the result
tm_results <- round(calculate_tm(level5[[i]]), 2)
# Combine the original column with the TM results
combined <- data.frame(level5[[i]], tm_results)
# Set the column names for the combined columns
original_col_name <- names(level5)[i]
names(combined) <- c(original_col_name, paste0(original_col_name, "_tm"))
# Bind the new combined columns to the result dataframe
level5_with_tm_result <- cbind(level5_with_tm_result, combined)
}
# Remove the first column if it contains only NA values from the placeholder creation
level5_with_tm_result <- level5_with_tm_result[, colSums(is.na(level5_with_tm_result)) < nrow(level5_with_tm_result)]
level5_with_tm_result
rownames(level5_with_tm_result) <- rownames(level5)
level5_with_tm_result
runApp()
source("functions.R")
primer = "rs53576, rs1815739, rs7412, rs429358, rs6152"
shift = 100
desired_tm = 60
diff = 4
Heterodimer_tm = 50
Homodimer <- 45
top <- 2
# We will start exploring options 800 bp away from the SNP location upstream and downstream
center <- 800
hairpin <- 45
# from that distance of 800, we will search the range from 600 to 1,000. (800+200 and 800-200)
far <- 200
start_distance <- 15
end_distance <- 30
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
upStream <- center
downStream <- center
snpmart <- useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp")
snp_sequence <- getBM(attributes = c('refsnp_id', 'snp'),
filters = c('snp_filter', 'upstream_flank', 'downstream_flank'),
checkFilters = FALSE,
values = list(snp_list, upStream, downStream),
mart = snpmart,
bmHeader = TRUE)
#Create a new data frame
snp_wrangled <- data.frame(matrix(ncol = 2, nrow = 0))
# Add each variation as a new string into each row
for (j in snp_sequence$`Variant name`){
for (i in list_seq(snp_sequence$`Variant sequences`[snp_sequence$`Variant name`==j])){
snp_wrangled[nrow(snp_wrangled) + 1,] <- c(j, i)
}
}
# Rename columns and data frame
colnames(snp_wrangled) = c("snpID", "sequence")
### I have a long long string. I want to get the left 18~25 charactors and
# between 300 ~ 800 units away, I want another 18 ~ 25
df <- all_text_warngling(snp_wrangled,
start_distance,
end_distance,
center,
far,
shift)
df
print("Primer generated")
print("R get filter activated")
# Applied filters before multiplexing
df <- stage1_filter(df, desired_tm, diff, Homodimer, hairpin)
print(df)
print("Filtered")
# Count how many candidates there are for each primer group
df <- df %>%
mutate(substrings_count = lengths(substrings),
faraway_count = lengths(faraway)) %>%
relocate(snpID, substrings_count, faraway_count, everything()) # Moves a block of columns
print("Tree search")
df
# Keep only certain amount of candidates
df[[4]] <- extract_top_n(df[[4]], top)
df[[5]] <- extract_top_n(df[[5]], top)
df <- df %>%
group_by(snpID) %>%
filter(substrings_count == max(substrings_count))
print(df)
level5 <- soulofmultiplex(df, Heterodimer_tm)
print(level5)
level5_with_tm_result <- get_tm_for_all_primers(level5)
level5_with_tm_result
level5_with_tm_result
View(level5_with_tm_result)
level5
level5_with_tm_result <- data.frame(matrix(NA, nrow = nrow(level5), ncol = 0))
# Apply the 'calculate_tm' function to each column of the dataframe
for (i in seq_along(level5)) {
# Calculate TM for the column and round the result
tm_results <- round(calculate_tm(level5[[i]]), 2)
# Combine the original column with the TM results
combined <- data.frame(level5[[i]], tm_results)
# Set the column names for the combined columns
original_col_name <- names(level5)[i]
names(combined) <- c(original_col_name, paste0(original_col_name, "_tm"))
# Bind the new combined columns to the result dataframe
level5_with_tm_result <- cbind(level5_with_tm_result, combined)
}
# Remove the first column if it contains only NA values from the placeholder creation
level5_with_tm_result <- level5_with_tm_result[, colSums(is.na(level5_with_tm_result)) < nrow(level5_with_tm_result)]
View(level5_with_tm_result)
rownames(level5_with_tm_result) <- rownames(level5)
level5_with_tm_result
View(level5_with_tm_result)
matrix_level5_with_tm_result <- as.matrix(level5_with_tm_result)
level5_with_tm_result <- as.matrix(level5_with_tm_result)
level5_with_tm_result <- data.frame(matrix(NA, nrow = nrow(level5), ncol = 0))
# Apply the 'calculate_tm' function to each column of the dataframe
for (i in seq_along(level5)) {
# Calculate TM for the column and round the result
tm_results <- round(calculate_tm(level5[[i]]), 2)
# Combine the original column with the TM results
combined <- data.frame(level5[[i]], tm_results)
# Set the column names for the combined columns
original_col_name <- names(level5)[i]
names(combined) <- c(original_col_name, paste0(original_col_name, "_tm"))
# Bind the new combined columns to the result dataframe
level5_with_tm_result <- cbind(level5_with_tm_result, combined)
}
# Remove the first column if it contains only NA values from the placeholder creation
level5_with_tm_result <- level5_with_tm_result[, colSums(is.na(level5_with_tm_result)) < nrow(level5_with_tm_result)]
rownames(level5_with_tm_result) <- rownames(level5)
View(level5_with_tm_result)
level5_with_tm_result <- data.frame(matrix(NA, nrow = nrow(level5), ncol = 0))
View(level5_with_tm_result)
runApp()
options(scipen = 999)
runApp()
source("functions.R")
options(repos = BiocManager::repositories())
options(scipen = 999)
primer = "rs53576, rs1815739, rs7412, rs429358, rs6152"
shift = 100
desired_tm = 64
diff = 3
Heterodimer_tm = 50
Homodimer <- 45
top <- 2
# We will start exploring options 800 bp away from the SNP location upstream and downstream
center <- 800
hairpin <- 45
# from that distance of 800, we will search the range from 600 to 1,000. (800+200 and 800-200)
far <- 200
start_distance <- 15
end_distance <- 30
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
upStream <- center
downStream <- center
snpmart <- useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp")
snp_sequence <- getBM(attributes = c('refsnp_id', 'snp'),
filters = c('snp_filter', 'upstream_flank', 'downstream_flank'),
checkFilters = FALSE,
values = list(snp_list, upStream, downStream),
mart = snpmart,
bmHeader = TRUE)
#Create a new data frame
snp_wrangled <- data.frame(matrix(ncol = 2, nrow = 0))
# Add each variation as a new string into each row
for (j in snp_sequence$`Variant name`){
for (i in list_seq(snp_sequence$`Variant sequences`[snp_sequence$`Variant name`==j])){
snp_wrangled[nrow(snp_wrangled) + 1,] <- c(j, i)
}
}
# Rename columns and data frame
colnames(snp_wrangled) = c("snpID", "sequence")
### I have a long long string. I want to get the left 18~25 charactors and
# between 300 ~ 800 units away, I want another 18 ~ 25
df <- all_text_warngling(snp_wrangled,
start_distance,
end_distance,
center,
far,
shift)
df
print("Primer generated")
print("R get filter activated")
# Applied filters before multiplexing
df <- stage1_filter(df, desired_tm, diff, Homodimer, hairpin)
print(df)
print("Filtered")
# Count how many candidates there are for each primer group
df <- df %>%
mutate(substrings_count = lengths(substrings),
faraway_count = lengths(faraway)) %>%
relocate(snpID, substrings_count, faraway_count, everything()) # Moves a block of columns
print("Tree search")
df
# Keep only certain amount of candidates
df[[4]] <- extract_top_n(df[[4]], top)
df[[5]] <- extract_top_n(df[[5]], top)
df <- df %>%
group_by(snpID) %>%
filter(substrings_count == max(substrings_count))
print(df)
level5 <- soulofmultiplex(df, Heterodimer_tm)
df
list_3 <- list()
for (i in 1:length(df[[1]])){
list_3 <- c(list_3,
list(unlist(df[[4]][[i]])),
list(unlist(df[[5]][[i]])))
}
# Arrange the list from small to big
arranged_list <- list_3
# Prepare the initial list for multiplexing
level2 <- list()
level3 <- list()
level4 <- list()
level2 <- incoming_list(arranged_list[[1]])
level3 <- replace_end_nodes(incoming_list(arranged_list[[1]]),
incoming_list(arranged_list[[2]])
)
if (length(arranged_list) != 2) {
level3 <- replace_end_nodes(level3,
incoming_list(arranged_list[[3]])
)
str(level3)
# arranged_list
# Running
print(length(arranged_list))
for (i in 4:length(arranged_list)){
# Start a timer
start_time <- Sys.time()
# Get all the end points from the tree
endpoints <- get_endpoints(level3)
# Endpoints come back a little messy
endpoints <- clean_endpoints(endpoints)
print(paste("Start with ", length(endpoints)))
# Evalauate all the ned points to its parents
bad_nodes <- compute_bad_nodes(endpoints, Heterodimer_tm)
print(paste("We are removing: ", length(bad_nodes)))
# Remove bad nodes if there are any
if (length(bad_nodes) != 0){
level3 <- Iterate_remove(level3,bad_nodes)
level3 <- remove_empty_lists(level3)
}
# If all nodes are bad, return NULL
if (length(endpoints) == length(bad_nodes)){
print("All nodes are removed during the process")
return(NULL)
}
print(paste("After trimming: ", length(get_endpoints(level3))))
# Stop adding list if we are at the last level
if (1){
level4 <- incoming_list(arranged_list[[i]])
print(paste("New list: ", length(level4)))
level3 <- replace_end_nodes(level3, level4)
print(paste("level3 + level4: ", length(get_endpoints(level3))))
}
# Summarize results for this level
print(paste("How far are we: ", i))
print(paste("Time" , round(Sys.time() - start_time, 1)))
print("--------------------------")
}
}
# arranged_list
# Running
print(length(arranged_list))
arranged_list
list_3 <- list()
df
df[[1]]
lapply(df[[1]], unique)
df[!duplicated(df$snpID), ]
# Techincal debt
df <- df[!duplicated(df$snpID), ]
df
df <- df %>%
group_by(snpID) %>%
filter(substrings_count == max(substrings_count))
print(df)
level5 <- soulofmultiplex(df, Heterodimer_tm)
print(level5)
runApp()
snp_sequence
library(rprimer)
## Enter the filepath to an alignment with target sequences of interest
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")
## Import the alignment
myAlignment <- readDNAMultipleAlignment(filepath, format = "fasta")
library(rprimer)
## Enter the filepath to an alignment with target sequences of interest
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")
## Import the alignment
myAlignment <- readDNAMultipleAlignment(filepath, format = "fasta")
library(Biostrings)
## Import the alignment
myAlignment <- readDNAMultipleAlignment(filepath, format = "fasta")
## Design primers, probes and assays (modify settings if needed)
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
myOligos <- oligos(myConsensusProfile)
BiocManager::install("oligo")
library(oligo)
myOligos <- oligos(myConsensusProfile)
library(oligo)
library(rprimer)
library(Biostrings)
## Enter the filepath to an alignment with target sequences of interest
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")
## Import the alignment
myAlignment <- readDNAMultipleAlignment(filepath, format = "fasta")
## Design primers, probes and assays (modify settings if needed)
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
myOligos <- oligos(myConsensusProfile)
myOligos <- designOligos(myConsensusProfile)
BiocManager::install("GenomeInfoDb")
library(rprimer)
library(Biostrings)
library(GenomeInfoDb)
library(XVector)
library(IRanges)
library(S4Vectors)
library(BiocGenerics)
# library(rprimer) # Uncomment this if rprimer is installed and available
library(kableExtra)
# library(rprimer) # Uncomment this if rprimer is installed and available
library(kableExtra)
# BiocManager::install("XVector")
# BiocManager::install("IRanges")
# BiocManager::install("S4Vectors")
# BiocManager::install("BiocGenerics")
# BiocManager::install("BiocStyle")
#
# # Install rprimer (assuming it's available in a known repository, replace with correct source if not)
# # BiocManager::install("rprimer")
#
# # Install CRAN package
install.packages("kableExtra")
# library(rprimer) # Uncomment this if rprimer is installed and available
library(kableExtra)
library(BiocStyle)
# BiocManager::install("GenomeInfoDb")
# BiocManager::install("XVector")
# BiocManager::install("IRanges")
# BiocManager::install("S4Vectors")
# BiocManager::install("BiocGenerics")
BiocManager::install("BiocStyle")
library(BiocGenerics)
# library(rprimer) # Uncomment this if rprimer is installed and available
library(kableExtra)
library(BiocStyle)
library(S4Vectors)
library(rprimer)
library(Biostrings)
library(GenomeInfoDb)
library(XVector)
library(IRanges)
library(S4Vectors)
library(BiocGenerics)
# library(rprimer) # Uncomment this if rprimer is installed and available
library(kableExtra)
library(BiocStyle)
## Enter the filepath to an alignment with target sequences of interest
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")
## Import the alignment
myAlignment <- readDNAMultipleAlignment(filepath, format = "fasta")
## Design primers, probes and assays (modify settings if needed)
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
myOligos <- oligos(myConsensusProfile)
BiocManager::install("Biostrings")
library(rprimer)
library(Biostrings)
## Enter the filepath to an alignment with target sequences of interest
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")
## Import the alignment
myAlignment <- readDNAMultipleAlignment(filepath, format = "fasta")
## Design primers, probes and assays (modify settings if needed)
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
myOligos <- oligos(myConsensusProfile)
myAssays <- assays(myOligos)
## Visualize the results
plotData(myConsensusProfile)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("rprimer")
myOligos <- oligos(myConsensusProfile)
## Enter the filepath to an alignment with target sequences of interest
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")
## Import the alignment
myAlignment <- readDNAMultipleAlignment(filepath, format = "fasta")
## Design primers, probes and assays (modify settings if needed)
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
myOligos <- oligos(myConsensusProfile)
myAssays <- assays(myOligos)
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
plotData(myConsensusProfile)
selection <- myConsensusProfile[
myConsensusProfile$position >= 5000 & myConsensusProfile$position <= 5800,
]
plotData(selection)
myOligos <- designOligos(myConsensusProfile)
plotData(myOligos)
myMaskedConsensusProfile <- consensusProfile(myMaskedAlignment, ambiguityThreshold = 0.05)
system.file("extdata", "example_alignment.txt", package = "rprimer")
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")
myAlignment <- readDNAMultipleAlignment(filepath, format = "fasta")
## Mask everything but position 3000 to 4000 and 5000 to 6000
myMaskedAlignment <- myAlignment
colmask(myMaskedAlignment, invert = TRUE) <- c(3000:4000, 5000:6000)
myMaskedAlignment
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
plotData(myConsensusProfile)
selection <- myConsensusProfile[
myConsensusProfile$position >= 5000 & myConsensusProfile$position <= 5800,
]
plotData(selection)
myOligos <- designOligos(myConsensusProfile)
myOligos
View(myOligos)
shiny::runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
shiny::runApp('Multiplexing App')
runApp('Multiplexing App')
install.packages("shinyWidgets")
library(shinyWidgets)
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
runApp('Multiplexing App')
